<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>领域概念：信号隔离</title>
    <meta content="1200" property="og:image:width"/>
    <meta content="630" property="og:image:height"/>
    <link rel="icon" href="../../img/icon.png">
    <link as="font" crossorigin="" href="../../Agrandir-Heavy.2fd076131b76.woff2" rel="preload"
          type="font/woff2"/>
    <link as="font" crossorigin="" href="../../Agrandir-Bold.5adcade67872.woff2" rel="preload"
          type="font/woff2"/>
    <link as="font" crossorigin="" href="../../source-sans-pro-v14-latin-regular.899c8f78ce65.woff2"
          rel="preload" type="font/woff2"/>
    <link as="font" crossorigin="" href="../../Agrandir-Regular.11a4ceb99823.woff2" rel="preload"
          type="font/woff2"/>
    <link as="font" crossorigin="" href="../../source-sans-pro-v14-latin-600.c85615b29630.woff2" rel="preload"
          type="font/woff2"/>
    <link href="../../common.0016184b0568.css" rel="stylesheet" type="text/css"/>
    <link href="../../home.a12d472bcf09.css" rel="stylesheet" type="text/css"/>
    <link href="../content-page.css" rel="stylesheet" type="text/css"/>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad: true});</script>
    <script src="../../../bower_components/bower-webfontloader/webfont.js"></script>
    <script src="../../../bower_components/snap.svg/dist/snap.svg-min.js"></script>
    <script src="../../../bower_components/underscore/underscore-min.js"></script>
    <script src="../../../bower_components/js-sequence-diagrams/dist/sequence-diagram-min.js"></script>
    <link href="../../../bower_components/js-sequence-diagrams/dist/sequence-diagram-min.css" rel="stylesheet"/>
</head>
<header class="site-header">
    <br/>
    <h1 style="margin: 0 auto;text-align: left;margin: 0 50px;color: white;font-size: 3.5rem">
        <img src="../../svg/icon-white.svg" height="80" width="80" alt=""/>&nbsp;&nbsp;Neil's wiki
        <button class="subscribe" onclick="location.href='../subscribe/index.html'">Subscribe</button>
    </h1>
    <br/>
</header>
<body class="content-body">
<div class="content-body-class">
    <h1 class="hosting-pricing-plan-block__header">领域驱动设计</h1>
    <div class="content-infos">
        <div class="content-h2">
            0. Preface
        </div>
        <div class="content-list">
            1. 协同开发不要破坏软件的概念完整性（语义一致性）
        </div>
        <div class="content-list">
            2. 软件的本质是设计与领域，而非新的技术栈
        </div>
        <div class="content-list">
            3. 重构是在代码实现层面对抗腐烂变质，而 DDD 是在代码架构设计层面对抗腐烂变质（控制复杂性）
        </div>
        <div class="content-list">
            4. 关注精简的业务模型及实现的匹配
            <div class="content-list">
                1. OOP中，哪些对象对系统有用？哪些对象对拟建系统没有用处？我们该怎么保证选取的对象模型恰好够用？
            </div>
            <div class="content-list">
                2. 如何保留对象中有用的关系，去除无用的关系，并限定变更范围以降低系统的复杂度？
            </div>
            <div class="content-list">
                3. 业务驱动设计是DDD的观点，如果DDD特别关注的是
                <span class="content-mention">MDD</span>
                （模型驱动设计）
                <span class="content-mention">MDA</span>
                （模型驱动架构）中
                <span class="content-mention">M</span>
                以及其实现，那么这个M如何与架构、开发过程相融合？
            </div>
            <div class="content-list">
                4. 不同的团队模型会让一个模型实现更优秀或者更糟糕
            </div>
            <div class="content-list">
                5. 面向对象技术，或者说是提炼的模型如何在工程中使用？
            </div>
            <div class="content-list">
                6. 一个项目使用统一的模型，还是分解为不同的模型？
            </div>
        </div>
        <div class="content-h2">
            1. What is DDD ?
        </div>
        <div class="content-h3">
            Information
        </div>
        <div class="content-words">
            软件开发通常是真实世界中已存在流程的自动化，或为真实业务问题提供的解决方案。软件的领域是<b>需要自动化的业务或真实世界的问题</b>。从一开始，我们就必须明白软件起源于领域并与其领域密切相关。
        </div>
        <div class="content-words">
            创建一个好的软件，必须要知道软件究竟是什么。在充分了解金融业务是什么之前，是做不出好的银行业软件系统的。
        </div>
        <div class="content-words">
            银行的从业者最清楚银行业业务，他们知道所有的细节、困难、可能出现的问题、业务规则。这些就是我们永远的起点：<b>领域</b>。软件的最终目的是增进一个<b>特定</b>的领域。为了达到这个目的，软件需要与它服务的领域和谐共处，否则就会导致很大的混乱。
        </div>
        <div class="content-words">
            如何使软件与领域和谐共处？最佳方式是让软件成为其领域的映射。软件需要包含领域里的重要核心概念和元素，并精准实现其关系。也就是说，软件需要对领域进行建模。对银行业业务不了解的人也可以阅读此代码学习大量知识。
        </div>
        <div class="content-words">
            <b>对软件进行领域建模需要去产出一个领域模型，一个经过严格组织并选择性抽象的知识。</b>
        </div>
        <div class="content-words">
            模型是对目标领域内部的展现方式，会贯穿设计与开发的全过程。我们需要组织信息并将其系统化、分割成小一点的信息块，再将信息块放入逻辑块中，进行分离关注。
        </div>
        <div class="content-words">
            模型需要更精准、更完整、没有二义性，我们需要模型来交流。
        </div>
        <div class="content-words">
            瀑布设计方法的缺点是分析人员与开发人员间信息的不可见，另一种方法叫做敏捷，深入了解客户领域及需求变化，持续产出客户需要的软件。但有过度工程、过度设计的可能性。
        </div>
        <div class="content-h3">
            Construct domain knowledge
        </div>
        <div class="content-h4">
            范例
        </div>
        <div class="content-imports">
            在给定的时刻，空中会有成千上万的飞机。它们会朝着各自的目的地按照路线飞行，很重要的事是需要确保它们不会在空中碰撞。我们不会试图描述一个完整的交通系统，而只是关注其中的一个小小的子集：<b>飞行监控系统</b>。<br/>
            飞行监控系统会跟踪指定区域内的任意航班，判断班机是否遵照预定航线，以及是否可能碰撞。
        </div>
        <div class="content-h4">
            分析
        </div>
        <div class="content-words">
            软件开发应从<b>理解领域</b>开始。
        </div>
        <div class="content-words">
            本例就是从空中监控系统开始。控制人员是这个领域的专家，但他们并不是软件领域的专家，你不能期望他们会给你提供一个关于他们问题的完整描述。
        </div>
        <div class="content-words">
            你听到的很可能是例如<u>飞机起飞、着陆、碰撞的危险、着陆</u>等杂乱无章的知识。
        </div>
        <div class="content-words">
            为了从看似杂乱无章的信息中寻找规律，我们需要从某个地方开始。
        </div>
        <div class="content-h5">
            Step 1
        </div>
        <div class="content-words">
            控制人员和你都认为飞行器必须拥有出发机场和目的机场：
        </div>
        <div class="mermaid middle">
            graph LR
            A(Departure) --> B(Aircraft)
            B --> C(Destination)
        </div>
        <div class="content-h5">
            Step 2
        </div>
        <div class="content-words">
            那么，飞机在飞行中时，发生了什么？控制人员说，会给每架飞机指派一个飞行计划，描述飞行的全过程。飞行计划是飞机在空中必须遵循的路径，也就是路线（Route）。这是一个重要的概念，其将出发机场和目的机场关联起来。所以将路线关联而不是将飞机关联似乎更合理与自然：
        </div>
        <div class="mermaid middle">
            graph LR
            A(Aircraft) --> B(Route)
            B --> C(Departure)
            B --> D(Destination)
        </div>
        <div class="content-h5">
            Step 3
        </div>
        <div class="content-words">
            进一步交流后，你发现路线是由小的区间段组成的曲线，所以路线可以被考虑成一系列的方位点：
        </div>
        <div class="mermaid middle">
            flowchart LR
            A(Aircraft) --> B(Route)
            B -- * --o C(Fix)
            C --> D(2DPoint)
        </div>
        <div class="content-h4">
            本质
        </div>
        <div class="content-words">
            本质上，你和领域专家交谈时，你们在交换知识。你在交谈中学习、理解领域，通过正确的问题正确地处理得到的信息。这样的模型一开始不能保证正确，但它是个开始点。
        </div>
        <div class="content-words">
            通常软件领域与领域专家人员会进行很长时间的讨论来交换知识。建立早期模型并验证其是否可以工作，修改模型就不再是开发人员的单项联系，而是存在反馈。这帮助我们更清晰、准确地理解领域。这样的模型体现两个专业领域的交汇，很消耗时间，但软件的最终目的是解决真实领域的业务问题，所以它必须与领域完美结合。
        </div>
        <div class="content-h2">
            2. The Ubiquitous language
        </div>
        <div class="content-h3">
            Request for public language
        </div>
        <div class="content-words">
            <b>两个领域合力开发领域模型带来的问题是语言不一致。</b>
        </div>
        <div class="content-words">
            开发人员满脑子都是类、方法、算法、模式，总是想将实际生活中的概念和程序中的工
            件做对应。他们希望看到要建立哪些对象类，要如何对对象类之间的关系建模。但领域专家一无所知，他们只了解他们特定领域的专业知识。克服此现象需要使用 <b>两个领域的公共语言</b>
            去描述领域，若不能共享一个公共语言来讨论领域，项目会面临严峻问题。
        </div>
        <div class="content-words">
            领域驱动设计的一个核心的原则是使用一种基于模型的语言。因为模型是软件满足
            领域的共同点，它很适合作为这种通用语言的构造基础。使用模型作为语言的主干，并要求团队在交流时使用一致的语言，在代码中也是这样。这就是通用语言（Ubiquitous Language）。
        </div>
        <div class="content-words">
            这种语言的形成并非一日之功，需要展开艰难的工作，确保发现语言的那些关键元素。我们需要发现定义领域和模型的关键概念，描述他们的适当用词，并开始使用它们。它们当中的一些概念很容易被发现，但另一些则不然。
        </div>
        <div class="content-words">
            <b>构建这样的语言会获取清晰的结果：模型与语言相互密切关联。一个对语言的变更会导致模型的变更。</b>
        </div>
        <div class="content-words">
            <b>开发人员应留意领域专家试图呈现设计中的内容存在的二义性或不一致的部分。</b>
        </div>
        <div class="content-h3">
            Create public language
        </div>
        <div class="content-h4">
            范例
        </div>
        <div class="middle" id="diagram-1"></div>
        <div class="mermaid middle">
            flowchart LR
            A(Aircraft) --> B(Flight Plan)
            B --> C(Route)
            C -- * --o D(Fix)
            D --> E(2DPoint)
        </div>

        <div class="middle" id="diagram-2"></div>
        <div class="content-words">
            UML很适合构建模型，它也真的是一种很好的记录关键概念及其关系的工具。但UML图一单复杂，即使是软件专家也很难阅读。所以，我们可以使用项目文档，通过小的图对模型的沟通，每一张小图包含了模型的一个子集，就像是分离关注<sup><a
                href="#1">[1]</a></sup>。这些文档甚至可以手绘——因为它达到比较稳定的状态前会发生多次变化。
        </div>
        <div class="content-words">
            <b>大图混乱，并不能传达比小图的集合更好理解，当然，也可以使用优秀的代码进行沟通（代码即注释），通过测试断言来描述行为。</b>
        </div>

        <div class="content-addition">
            <span id="1">[1] <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">https://en.wikipedia.org/wiki/Separation_of_concerns</a></span><br/>
        </div>
    </div>
</div>
</body>
</html>
<div class="back-to-home-page">
    <a class="call-to-action__link button" href="/">返回首页</a>
</div>
<script>
    var d = Diagram.parse("" +
        "开发人员->领域专家: 我们想监控空中交通，应该从哪里开始？\n" +
        "领域专家->开发人员: 让我们从最基础的开始吧。所有的交通由飞机组成。\n" +
        "领域专家->开发人员: 每架飞机从一个出发地起飞，并在一个目的地点着陆\n" +
        "开发人员->领域专家: 很容易嘛。在飞行时，飞机会按照驾驶员的意愿选择任何空中线路吗? \n" +
        "开发人员->领域专家: 是不是等于说他们可以决定他们能走哪条路，只要他们能到达终点?\n" +
        "领域专家->开发人员: 哦不。驾驶员会收到一条他们应该遵照的飞行路线。\n" +
        "领域专家->开发人员: 并且他们必须尽可能地 跟那条飞行路线吻合\n" +
        "开发人员->领域专家: 我会把这条路线考虑成空中的 3D 线路。\n" +
        "开发人员->领域专家: 如果我们使用笛卡尔系统坐标， \n" +
        "开发人员->领域专家: 那么一条飞行路线会被简化成一系列 3D 的点。\n" +
        "领域专家->开发人员: 我可不这么认为。我们不会这样看待飞行路线的。\n" +
        "领域专家->开发人员: 飞行路线实际上是飞机预期的空中线路在地面上的映射。\n" +
        "领域专家->开发人员: 飞行路线会穿过一系列地面上的点，\n" +
        "领域专家->开发人员: 而这些点我们可以用经度和纬度来决定。\n" +
        "开发人员->领域专家: 哦，那我们可以称每一个这样的点为一个方位，\n" +
        "开发人员->领域专家: 因为它是地球表面上的一个固定的点。\n" +
        "开发人员->领域专家: 我们将使用一系列2D的点来描述线路。\n" +
        "开发人员->领域专家: 顺便说一句，出发地和终点都属于方位。\n" +
        "开发人员->领域专家: 我们不再会将它们考虑成其他不同的概念\n" +
        "开发人员->领域专家: 飞行路线到达终点就如同它到达其他的方位一样。\n" +
        "开发人员->领域专家: 飞机必须遵照飞行路线，\n" +
        "开发人员->领域专家: 但这是否意味着它可以按照自己的意愿选择飞行高度呢?\n" +
        "领域专家->开发人员: 不。飞机在一个特定的时刻的海拔高度也会在飞行计划中有规定。\n" +
        "开发人员->领域专家: 飞行计划?那是什么意思?\n" +
        "领域专家->开发人员: 在离开机场之前，驾驶员会接到一个详细的飞行计划，\n" +
        "领域专家->开发人员: 包括所有关于这次飞行的信息：\n" +
        "领域专家->开发人员: 飞行路线、巡航高度、巡航速度和飞机的类型\n" +
        "领域专家->开发人员: 甚至机组成员的信息等\n" +
        "开发人员->领域专家: 噢，飞行计划看起来相当的重要。我们可得把它加到模型中。");
    d.drawSVG('diagram-1', {theme: 'simple'});
    d = Diagram.parse("" +
        "开发人员->领域专家: 好多了。当我看到这副图时，我会了解到很多事情。\n" +
        "开发人员->领域专家: 在监控空中交通时， 我们其实并不对飞机本身感兴趣，\n" +
        "开发人员->领域专家: 不管它是白色的还是蓝色的，也不管它是“波音”的还是“空客”的。\n" +
        "开发人员->领域专家: 我们对它们的“飞行”(flight)感兴趣。\n" +
        "开发人员->领域专家: 这才是我们实际上要跟踪和度量的东西。\n" +
        "开发人员->领域专家: 我认为我们应该对模型做些改变以确保其更加准确。");
    d.drawSVG('diagram-2', {theme: 'simple'});
</script>
