<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>领域概念：信号隔离</title>
    <meta content="1200" property="og:image:width"/>
    <meta content="630" property="og:image:height"/>
    <link rel="icon" href="../../img/icon.png">
    <link as="font" crossorigin="" href="../../Agrandir-Heavy.2fd076131b76.woff2" rel="preload"
          type="font/woff2"/>
    <link as="font" crossorigin="" href="../../Agrandir-Bold.5adcade67872.woff2" rel="preload"
          type="font/woff2"/>
    <link as="font" crossorigin="" href="../../source-sans-pro-v14-latin-regular.899c8f78ce65.woff2"
          rel="preload" type="font/woff2"/>
    <link as="font" crossorigin="" href="../../Agrandir-Regular.11a4ceb99823.woff2" rel="preload"
          type="font/woff2"/>
    <link as="font" crossorigin="" href="../../source-sans-pro-v14-latin-600.c85615b29630.woff2" rel="preload"
          type="font/woff2"/>
    <link href="../../common.0016184b0568.css" rel="stylesheet" type="text/css"/>
    <link href="../../home.a12d472bcf09.css" rel="stylesheet" type="text/css"/>
    <link href="../content-page.css" rel="stylesheet" type="text/css"/>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad: true});</script>
    <script src="../../../bower_components/bower-webfontloader/webfont.js"></script>
    <script src="../../../bower_components/snap.svg/dist/snap.svg-min.js"></script>
    <script src="../../../bower_components/underscore/underscore-min.js"></script>
    <script src="../../../bower_components/js-sequence-diagrams/dist/sequence-diagram-min.js"></script>
    <link href="../../../bower_components/js-sequence-diagrams/dist/sequence-diagram-min.css" rel="stylesheet"/>
</head>
<header class="site-header">
    <br/>
    <h1 style="margin: 0 auto;text-align: left;margin: 0 50px;color: white;font-size: 3.5rem">
        <img src="../../svg/icon-white.svg" height="80" width="80" alt=""/>&nbsp;&nbsp;Neil's wiki
        <button class="subscribe" onclick="location.href='../subscribe/index.html'">Subscribe</button>
    </h1>
    <br/>
</header>
<body class="content-body">
<div class="content-body-class">
    <h1 class="hosting-pricing-plan-block__header">领域驱动设计</h1>
    <div class="content-infos">
        <div class="content-addition">
            <span>本文基于<a href="https://github.com/VWWL/library/blob/main/计算机/软件模型/领域驱动设计.pdf">《领域驱动设计精简版》</a>整理，侵删。感谢InfoQ在软件之路上的贡献！</span><br/>
        </div>
        <div class="content-h2">
            0. Preface
        </div>
        <div class="content-list">
            1. 协同开发不要破坏软件的概念完整性（语义一致性）
        </div>
        <div class="content-list">
            2. 软件的本质是设计与领域，而非新的技术栈
        </div>
        <div class="content-list">
            3. 重构是在代码实现层面对抗腐烂变质，而 DDD 是在代码架构设计层面对抗腐烂变质（控制复杂性）
        </div>
        <div class="content-list">
            4. 关注精简的业务模型及实现的匹配
            <div class="content-list">
                1. OOP中，哪些对象对系统有用？哪些对象对拟建系统没有用处？我们该怎么保证选取的对象模型恰好够用？
            </div>
            <div class="content-list">
                2. 如何保留对象中有用的关系，去除无用的关系，并限定变更范围以降低系统的复杂度？
            </div>
            <div class="content-list">
                3. 业务驱动设计是DDD的观点，如果DDD特别关注的是
                <span class="content-mention">MDD</span>
                （模型驱动设计）
                <span class="content-mention">MDA</span>
                （模型驱动架构）中
                <span class="content-mention">M</span>
                以及其实现，那么这个M如何与架构、开发过程相融合？
            </div>
            <div class="content-list">
                4. 不同的团队模型会让一个模型实现更优秀或者更糟糕
            </div>
            <div class="content-list">
                5. 面向对象技术，或者说是提炼的模型如何在工程中使用？
            </div>
            <div class="content-list">
                6. 一个项目使用统一的模型，还是分解为不同的模型？
            </div>
        </div>
        <div class="content-h2">
            1. What is DDD ?
        </div>
        <div class="content-h3">
            Information
        </div>
        <div class="content-words">
            软件开发通常是真实世界中已存在流程的自动化，或为真实业务问题提供的解决方案。软件的领域是<b>需要自动化的业务或真实世界的问题</b>。从一开始，我们就必须明白软件起源于领域并与其领域密切相关。
        </div>
        <div class="content-words">
            创建一个好的软件，必须要知道软件究竟是什么。在充分了解金融业务是什么之前，是做不出好的银行业软件系统的。
        </div>
        <div class="content-words">
            银行的从业者最清楚银行业业务，他们知道所有的细节、困难、可能出现的问题、业务规则。这些就是我们永远的起点：<b>领域</b>。软件的最终目的是增进一个<b>特定</b>的领域。为了达到这个目的，软件需要与它服务的领域和谐共处，否则就会导致很大的混乱。
        </div>
        <div class="content-words">
            如何使软件与领域和谐共处？最佳方式是让软件成为其领域的映射。软件需要包含领域里的重要核心概念和元素，并精准实现其关系。也就是说，软件需要对领域进行建模。对银行业业务不了解的人也可以阅读此代码学习大量知识。
        </div>
        <div class="content-words">
            <b>对软件进行领域建模需要去产出一个领域模型，一个经过严格组织并选择性抽象的知识。</b>
        </div>
        <div class="content-words">
            模型是对目标领域内部的展现方式，会贯穿设计与开发的全过程。我们需要组织信息并将其系统化、分割成小一点的信息块，再将信息块放入逻辑块中，进行分离关注。
        </div>
        <div class="content-words">
            模型需要更精准、更完整、没有二义性，我们需要模型来交流。
        </div>
        <div class="content-words">
            瀑布设计方法的缺点是分析人员与开发人员间信息的不可见，另一种方法叫做敏捷，深入了解客户领域及需求变化，持续产出客户需要的软件。但有过度工程、过度设计的可能性。
        </div>
        <div class="content-h3">
            Construct domain knowledge
        </div>
        <div class="content-h4">
            范例
        </div>
        <div class="content-imports">
            在给定的时刻，空中会有成千上万的飞机。它们会朝着各自的目的地按照路线飞行，很重要的事是需要确保它们不会在空中碰撞。我们不会试图描述一个完整的交通系统，而只是关注其中的一个小小的子集：<b>飞行监控系统</b>。<br/>
            飞行监控系统会跟踪指定区域内的任意航班，判断班机是否遵照预定航线，以及是否可能碰撞。
        </div>
        <div class="content-h4">
            分析
        </div>
        <div class="content-words">
            软件开发应从<b>理解领域</b>开始。
        </div>
        <div class="content-words">
            本例就是从空中监控系统开始。控制人员是这个领域的专家，但他们并不是软件领域的专家，你不能期望他们会给你提供一个关于他们问题的完整描述。
        </div>
        <div class="content-words">
            你听到的很可能是例如<u>飞机起飞、着陆、碰撞的危险、着陆</u>等杂乱无章的知识。
        </div>
        <div class="content-words">
            为了从看似杂乱无章的信息中寻找规律，我们需要从某个地方开始。
        </div>
        <div class="content-h5">
            Step 1
        </div>
        <div class="content-words">
            控制人员和你都认为飞行器必须拥有出发机场和目的机场：
        </div>
        <div class="mermaid middle">
            graph LR
            A(Departure) --> B(Aircraft)
            B --> C(Destination)
        </div>
        <div class="content-h5">
            Step 2
        </div>
        <div class="content-words">
            那么，飞机在飞行中时，发生了什么？控制人员说，会给每架飞机指派一个飞行计划，描述飞行的全过程。飞行计划是飞机在空中必须遵循的路径，也就是路线（Route）。这是一个重要的概念，其将出发机场和目的机场关联起来。所以将路线关联而不是将飞机关联似乎更合理与自然：
        </div>
        <div class="mermaid middle">
            graph LR
            A(Aircraft) --> B(Route)
            B --> C(Departure)
            B --> D(Destination)
        </div>
        <div class="content-h5">
            Step 3
        </div>
        <div class="content-words">
            进一步交流后，你发现路线是由小的区间段组成的曲线，所以路线可以被考虑成一系列的方位点：
        </div>
        <div class="mermaid middle">
            flowchart LR
            A(Aircraft) --> B(Route)
            B -- * --o C(Fix)
            C --> D(2DPoint)
        </div>
        <div class="content-h4">
            本质
        </div>
        <div class="content-words">
            本质上，你和领域专家交谈时，你们在交换知识。你在交谈中学习、理解领域，通过正确的问题正确地处理得到的信息。这样的模型一开始不能保证正确，但它是个开始点。
        </div>
        <div class="content-words">
            通常软件领域与领域专家人员会进行很长时间的讨论来交换知识。建立早期模型并验证其是否可以工作，修改模型就不再是开发人员的单项联系，而是存在反馈。这帮助我们更清晰、准确地理解领域。这样的模型体现两个专业领域的交汇，很消耗时间，但软件的最终目的是解决真实领域的业务问题，所以它必须与领域完美结合。
        </div>
        <div class="content-h2">
            2. The Ubiquitous language
        </div>
        <div class="content-h3">
            Request for public language
        </div>
        <div class="content-words">
            <b>两个领域合力开发领域模型带来的问题是语言不一致。</b>
        </div>
        <div class="content-words">
            开发人员满脑子都是类、方法、算法、模式，总是想将实际生活中的概念和程序中的工
            件做对应。他们希望看到要建立哪些对象类，要如何对对象类之间的关系建模。但领域专家一无所知，他们只了解他们特定领域的专业知识。克服此现象需要使用 <b>两个领域的公共语言</b>
            去描述领域，若不能共享一个公共语言来讨论领域，项目会面临严峻问题。
        </div>
        <div class="content-words">
            领域驱动设计的一个核心的原则是使用一种基于模型的语言。因为模型是软件满足
            领域的共同点，它很适合作为这种通用语言的构造基础。使用模型作为语言的主干，并要求团队在交流时使用一致的语言，在代码中也是这样。这就是通用语言（Ubiquitous Language）<sup><a
                href="#1" id="source1">[1]</a></sup>。
        </div>
        <div class="content-words">
            这种语言的形成并非一日之功，需要展开艰难的工作，确保发现语言的那些关键元素。我们需要发现定义领域和模型的关键概念，描述他们的适当用词，并开始使用它们。它们当中的一些概念很容易被发现，但另一些则不然。
        </div>
        <div class="content-words">
            <b>构建这样的语言会获取清晰的结果：模型与语言相互密切关联。一个对语言的变更会导致模型的变更。</b>
        </div>
        <div class="content-words">
            <b>开发人员应留意领域专家试图呈现设计中的内容存在的二义性或不一致的部分。</b>
        </div>
        <div class="content-h3">
            Create public language
        </div>
        <div class="content-h4">
            范例
        </div>
        <div class="middle" id="diagram-1"></div>
        <div class="mermaid middle">
            flowchart LR
            A(Aircraft) --> B(Flight Plan)
            B --> C(Route)
            C -- * --o D(Fix)
            D --> E(2DPoint)
        </div>

        <div class="middle" id="diagram-2"></div>
        <div class="content-words">
            UML很适合构建模型，它也真的是一种很好的记录关键概念及其关系的工具。但UML图一单复杂，即使是软件专家也很难阅读。所以，我们可以使用项目文档，通过小的图对模型的沟通，每一张小图包含了模型的一个子集，就像是分离关注<sup><a
                href="#2" id="source2">[2]</a></sup>。这些文档甚至可以手绘——因为它达到比较稳定的状态前会发生多次变化。
        </div>
        <div class="content-words">
            <b>大图混乱，并不能传达比小图的集合更好理解，当然，也可以使用优秀的代码进行沟通（代码即注释），通过测试断言来描述行为。</b>
        </div>
        <div class="content-h2">
            3. Model-driven Design
        </div>
        <div class="content-words">
            通用语言应充分被应用于建模过程，以推动两领域间的交流。下一步是将模型实现为代码。这是非常重要的阶段。优良的模型为能成功转化成代码会得到有质量问题的软件。在这一个过程中，开发人员往往因为代码难以正确表达概念与关系而转以创建自己的设计。更多的类被添加进代码，进一步加大了原始模型与最终实现的差距。
        </div>
        <div class="content-words">
            <b>违背软件设计原则的模型是不建议的。选择一个能被轻易和准确地转换成代码的模型是很重要的。</b>
        </div>
        <div class="content-words">
            开发人员应参与并确保模型在软件中得到实现。如果其中某处有错误，尽早纠正。代码模型的一个变更其实就隐含对模型的变更。
            <b>若分析人员与开发人员分离，最终的结果是模型将不再实用。</b>
            软件系统中的模型需要确保能如实反映领域模型，让映射显而易见。甚至可以让让软件模型如你所愿反映出对领域更深层的理解。
        </div>
        <div class="content-h3">
            Main constituent elements of Model-driven Design
        </div>
        <div class="content-words">
            接下来会展现模型驱动设计中要是用的最重要的模式。这些模式的作用是从领域驱动设计的角度展现一些<b>对象建模</b>和<b>软件设计</b>的关键元素。
        </div>
        <div class="content-h4">
            模式与模式间的总图：
        </div>
        <div class="mermaid middle">
            flowchart LR
            SU(Smart UI)x-- 相互排斥的选择 --xMDD(Model-driven Design)
            MDD-- 表达模型 --> S(Services)
            MDD-- 表达模型 --> E(Entities)
            E-- 访问 --> R(Repositories)
            E-- 封装 --> F(Factories)
            E-- 扮演 or 保持完整性 --> A(Aggregates)
            A-- 访问 --> R
            A-- 封装 --> F
            MDD-- 表达模型 --> VO(Value Objects)
            MDD-- 领域隔离 --> LA(Layered Architecture)
            VO-- 封装 --> A
            VO-- 封装 --> F
        </div>
        <div class="content-h4">
            分层架构
        </div>
        <div class="mermaid middle">
            flowchart LR
            subgraph Infrastructure
            In1(Infrastructure 1)
            In2(Infrastructure 2)
            In3(Infrastructure 3)
            In4(Infrastructure 4)
            end
            subgraph Domain
            D1(Domain 1)
            D2(Domain 2)
            end
            subgraph Application
            A1(Application 1)
            A2(Application 2)
            end
            subgraph User Interface
            I1(Interface 1)
            I2(Interface 2)
            end
            I2-->A2
            I1-->A1
            I1-->In1
            I1-->D1
            A1-->D1
            A2-->D2

            D1-->In2
            D1-->In4
            A2-->In4
        </div>
        <div class="content-words">
            我们创建软件应用时，这个应用很大一部分没有直接与领域关联，但它们是基础设施的一部分或是为 软件本身提供服务的。最好能让应用中的领域部分与其他部分相比保持尽可能小（也不是掺杂在一起）。
        </div>
        <div class="content-words">
            在面向对象程序中，UI界面、数据库等支持性代码经常被直接写到业务对象中，附加的业务逻辑被嵌入到UI组件和数据库脚本的行为中，这样做可以让事情快速工作起来。但是，当领域相关的代码被混入其他层时，要阅读和思考这些代码也变得极其困难。表面上是对UI的修改，却变成了对业务逻辑的修改。对业务规则的变更又需要跟踪其他代码。实现都粘连在了一起，模型驱动对象<sup><a
                href="#3" id="source3">[3]</a></sup>
            (model-driven objects) 于是变得不再可行，也很难展开自动化测试。<b>所以对于所有活动中包含的全部技术和逻辑而言，程序必须保持简单，否则就会难以理解。</b>
        </div>
        <div class="content-words">
            <b>因此，将复杂的程序划分成很多层。为每个层开发一个内聚设计，让每个层仅依赖于它下方的层。遵照标准的架构模式实现与上面的层的低耦合。将领域模型相关的代码集中到一个层中</b>
            ，把它从用户界面、应用和基础设施代码中隔离开来。领域对象不必在承担显示自己、保存自己、管理应用任务的职责，而是专注于表达领域模型。这会让一个模型逐渐进化的足够丰满、清晰，以便于捕获最基本的业务知识，并能够正常工作。
        </div>
        <div class="content-words">
            领域驱动设计的架构的通用解决方案包含了4个概念层：
        </div>
        <table class="content-table">
            <tr>
                <th>名称</th>
                <th>作用</th>
            </tr>
            <tr>
                <th>展现层</th>
                <td>负责向用户展现信息以及解释用户命令</td>
            </tr>
            <tr>
                <th>应用层</th>
                <td>很薄的一层，用来协调应用的活动。<br/>它不包含业务逻辑，也不保留业务对象的状态<br/>但它保留有应用任务的进度状态</td>
            </tr>
            <tr>
                <th>领域层</th>
                <td>本层包含关于领域的信息。<br/>这是业务软件的核心所在。<br/>这里保留业务对象的状态。<br/>对业务对象和它们状态的持久化被委托给了基础设施层</td>
            </tr>
            <tr>
                <th>基础设施层</th>
                <td>本层作为其他层的支撑库存在。<br/>它提供了层间的通信，实现对业务对象的持久化，<br/>包含对展现层的支持库等作用</td>
            </tr>
        </table>
        <div class="content-words">
            建立层的边界与通信规则很重要。如果代码没有被清晰地隔离到一些层中，就会很快发生混乱。
        </div>
        <div class="content-words">
            领域层应该关注核心的领域问题，不应该包括基础设施方面的活动；用户界面不该与业务逻辑捆绑，也不该与属于基础设施层的任务紧紧捆绑；应用层在很多情况下是必要的，它会成为业务逻辑之上的管理者，用来
            <b>监督和协调</b>应用内的一切活动。
        </div>
        <div class="content-h4">
            Entities
        </div>
        <div class="content-words">
            <b>有一类对象看上去好像拥有标识符，它的标识符在历经软件的各种状态变更后仍能保持一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至能够超出软件系统的生命周期。我们把这样的对象称为实体。</b>
        </div>
        <div class="content-words">
            <b>如果一个类可以创建多个完全相当却拥有不同引用的对象，那它们并不是实体。</b>例如天气信息类，很容易产生不同的实例，但其拥有不同的引用。
        </div>
        <div class="content-words">
            例如银行会计系统，每个账户拥有其自己的编号。每个账户可以用编号来精确的标识，这个编号在系统的生命周期中保持不变，并保证延续性。当一个对象可以用其标志符而不是属性来区分时，可将标志符作为在模型中该对象定义的主要部分。使类的定义保持简单并专注于生命周期的延续性和标志符。
            <b>这个标志符可以确保对每个对象产生一个唯一结果集的操作。</b>
        </div>
        <div class="content-words">
            实体是领域模型中非常重要的对象，定义一个对象是否是一个实体也很重要。
        </div>
        <div class="content-h4">
            Value Objects
        </div>
        <div class="content-words">
            跟踪与创建标志符需要很大的成本，并且我们需要很多仔细的考虑来决定由什么构成一个标志符，跟踪也不是易事。成千上万的实体也会给系统性能带来严重的下降，这不是我们期望的。
        </div>
        <div class="content-words">
            有些时候我们需要包含一个领域对象的某些属性，但我们对它是哪个对象并不感兴趣，而只关心它拥有的属性。
            <b>用来描述领域的特定方面、并没有标识符的一个对象，叫做值对象。</b>
        </div>
        <div class="content-words">
            值对象可以被轻易的创建和丢弃。极力推荐奖值对象实现为不可变的。它们由一个构造器创建，并且在它们的生命周期内永远不会修改。这是很必要的，不可变对象可以维持一致性。
        </div>
        <div class="content-words">
            <b>如果值对象是可共享的，那么它们应该是不可变的。值对象应该保持很小、很简单。当其他参与方需要一个值对象时，可以简单地传递值，或者创建一个副本。制作一个值对象的副本是非常简单的，通常不会有什么副作用。如果没有标识符，
                你可以按你所需创建若干副本，然后根据需要来销毁它们。</b>
        </div>
        <div class="mermaid middle">
            classDiagram
            class OriginalCustomer {
            customerId
            name
            street
            city
            state
            }
            NewCustomer <|-- Address
            NewCustomer: customerId
            NewCustomer: name
            NewCustomer: address
            class Address {
            street
            city
            state
            }
        </div>
        <div class="content-words">
            值对象可以包含任何值对象，或是对实体对象的引用。属性可以被分组到不同的对象中，被选择用来构成一个值对象的属性应该形成一个概念上的整体。
        </div>
        <div class="content-h4">
            Service
        </div>
        <div class="content-words">
            有一些领域中的动作，看上去不属于任何对象。它们代表了领域中的重要行为，不能忽略它们或简单地把他们合并到某个实体或值对象中。给一个对象增加这样的行为会破坏这个对象，让这个对象拥有了本不该属于它的功能。这样的行为从领域中被识别出来时，
            <b>最佳实践是将其声明为一个服务</b>。这样的对象不再有内置的状态，而仅仅是为领域提供相应的功能。
        </div>
        <div class="content-words">
            服务可以将服务于实体和值对象的相关功能进行分组。最好显示声明服务，因为它在领域中创建了一个清晰的区分，它封装了一个概念，这个概念相当于一个操作的接口。
        </div>
        <div class="content-words">
            服务也能被运用于领域层。一个服务不是与执行服务的对象有关，而是与操作所要执行的对象有关。这种情况下，服务通常变成了多个对象的一个连接点。这也是为什么行为应该很自然的隶属于一个服务而不是被包含在领域对象中的一个原因。这也是行为必须在服务下而不被包含在领域对象中的一个原因——这会导致高耦合度。
        </div>
        <div class="content-words">
            一个操作凸显为领域的重要概念时，就需要为它创建一个服务。以下是服务的三个特征：
        </div>
        <div class="content-list">
            1. 服务执行的操作代表了一个领域概念，这个无法自然的隶属于一个实体或值对象
        </div>
        <div class="content-list">
            2. 被执行的操作涉及到领域的其他对象
        </div>
        <div class="content-list">
            3. 操作是无状态的
        </div>
        <div class="content-words">
            <b>当一个重要过程、操作应该是个服务时，根据模型的语言定义一个接口，并确保操作的名字是通用语言中的一部分。</b>
            使用服务时，保持领域层的隔离非常重要。我们在设计阶段建立模型时，需要确保将领域层与其他层隔离开。如果服务在概念上属于应用层，
            则将服务放入应用层。如果服务关于领域对象，而且确实与领域有关的、为领域的需要服务，那么它就属于领域层。
        </div>
        <div class="content-h4">
            Module
        </div>
        <div class="content-words">
            模块发展到某个规模后，将它作为整体来讨论很困难，理解不同部件的关系和交互变得很困难。所以，必须要将模块组织到模块中。
            <b>模块被用来作为组织相关概念和任务以便于降低复杂性的一种方法。</b>
            查看模块包含的内容以及其间的关系，就很容易掌握大型模型的情况。
        </div>
        <div class="content-words">
            软件普遍上应该具有高内聚和低耦合，它也可以被应用于模块级别。推荐的做法是将高关联度的类分组到一个模块，以提供尽大的内聚性。最常见的内聚是通信性内聚（Communicational
            cohesion）<sup><a
                href="#4" id="source4">[4]</a></sup>和功能性内聚（Functional
            cohesion）<sup><a
                href="#5" id="source5">[5]</a></sup>。在模块中的部件操作相同相同的数据时，可以得到通信性内聚。在模块中的部件协同工作以完成定义好的任务时，可以得到功能性内聚。功能性内聚是最佳的内聚模型。
        </div>
        <div class="mermaid middle">
            flowchart LR
            subgraph 调方域
            D1(Domain) -- 4 实现 --> G1
            A1(Application) -- 3 --> D1
            G1(Gateways) -- 2 --> A1
            end
            subgraph 被调方域
            D(Domain) -- 7 实现 --> G
            A(Application) -- 6 调用 --> D
            G(Gateways)
            end
            U(用户发送请求) -- 1 --> G1
            A -. &nbsp&nbsp&nbsp&nbsp&nbsp&nbspGateways依赖Application .-> G1
            G1 -- 5 调用 --> A
        </div>
        <div class="content-words">
            模块应由在功能上或逻辑上属于一体的元素构成，以确保内聚性。模块应该具有定义好的接口并可以被其他模块访问。如果模块间仅有极少的连接，通过连接来执行定义好的功能，能让人更容易理解系统如何工作。
        </div>
        <div class="content-words">
            应该选择那些能够表达系统功能并且包含具有内聚性的一组概念的模块。这样做常常会降低模块间的耦合。
            <b>重新定义模型，直到能够按照高级别的领域概念将它区分开来，而且对应的代码也被很好地解耦。</b>
        </div>
        <div class="content-words">
            <b>模块名称会成为通用语言的组成部分。模块和它们的名称能够反映出对领域的深层理解。</b>
        </div>
        <div class="content-words">
            模块的设计应灵活，允许随着项目进展而变化，并不应该被冻结。
        </div>
        <div class="content-h3">
            Next
        </div>
        <div class="content-words">
            管理领域对象的生命周期自身就会遇到一个挑战，如果做得不恰当，就会对领域模型产生负面影响。下面三个模式帮助我们处理这个挑战。
        </div>
        <div class="content-words">
            聚合是用来定义对象所有权和边界的领域模式；工厂和资源库是另外的两种设计模式，用来帮助我们处理对象的创建与存储问题。
        </div>
        <div class="content-words">
            工厂和资源库之间存在一定的关系。它们都是模型驱动设计中的模式，它们都能帮助我们管理领域对象的生命周期。
        </div>
        <div class="content-words">
            然而工厂关注的是对象的创建，而资源库关注的是已经存在的对象。
        </div>
        <div class="content-words">
            资源库可能会在本地缓存对象，但更常见的情况是需要从一个持久化存储中检索它们。对象可以通过构造器创建，也可以通过一个工厂来构建。出于这个理由，
            资源库也可以被看作是一个工厂，因为它会创建对象。然而它不是从无到有创建新的对象，而是重建已有的对象。我们不应该将资源库与工厂混合在一起。工厂应该用来创建
            新的对象，而资源库应该用来发现已经创建的对象。当一个新对象被添加到资源库时， 它应该是先由工厂创建好的，然后它应该被传递给资源库，由资源库来保存它。
        </div>
        <div class="middle" id="diagram-3"></div>
        <div>另外要注意的是工厂是“纯的领域”，而资源库会包含到基础设施的连接，例如数据库。</div>
        <div class="content-h4">
            Aggregate
        </div>
        <div class="content-words">
            无论设计时有多少考虑，我们都会看见一个模型中很多对象会与其他对象发生关联，进而形成复杂的关系网。对模型中每一个可导航的关联而言，都应该有对应的软件机制加强它。来自模型的挑战常常不是让它们尽量完整，而是让它们尽量简单和容易理解。这就意味着，我们需要对模型中的关系进行消减和简化。
        </div>
        <div class="content-h5">
            例如
        </div>
        <div class="content-list">
            1. 一对多关联关系通常可以被简单的转化为一个对象与其他对象的集合之间的关联
        </div>
        <div class="content-list">
            2. 多对多关联的简化很困难。关联的数字应该被尽可能的减小。
            <div class="content-list">
                1. 要删除模型中非基本的关联关系。他们可能在领域中存在但在模型中不必要。
            </div>
            <div class="content-list">
                2. 通过添加约束减少多重性。如果很多对象满足一种关系，那么这个关系上加上正确的约束后，很可能只有一个对象会继续满足这种关系。
            </div>
            <div class="content-list">
                3. 很多时候双向关联可以转化为非双向关联。例如：每一辆汽车都有一台发动机，并且发动机在运转时，都会属于一辆汽车。这种关系是双向的，但是很容易将其简化为汽车拥有发动机，而不用考虑反向的。
            </div>
        </div>
        <div class="content-list">
            减少关联后，我们仍然可能会获得很多关系。一个银行系统会保留并处理客户数据。这些数据包括客户的个人数据（例如姓名、地址、电话号码、工作描述等）和账户数据：账户、余额、执行的操作等。
        </div>
        <div class="content-list">
            当系统归档或者完全删除一个客户的信息时，必须要确保所有的引用都被删除了。如果许多对象持有这样的引用，则很难确保它们全被清除了。同样地，如果一个客户的某些数据发生了变化，系统必须确保在整个系统中执行了适当的更新，数据的一致性必须得到保证。这通常是在数据库层面进行处理的。通常会使用事务来确保数据的一致性。但是如果模型没有被仔细地设计过，会产生很大程度的数据库争夺，导致性能很差。当数据库事务在这样的操作中担负重要角色时，我们会期望直接在模型中解决跟数据一致性相关的一些问题。
        </div>
        <div class="content-words">
            所以，在模型拥有复杂关联的对象发生变化时，很难保证一致性。因此使用聚合。
        </div>
        <div class="content-words">
            聚合是针对数据变化可以考虑成一个单元的一组关联对象。聚合使用边界将内部与外部划分开来。
        </div>
        <div class="content-words">
            <b>每个内聚都有一个根，这个根是一个实体，且是外部可以访问唯一的对象。</b>
            根对象可以持有对任意聚合对象的引用，其他的对象可以互相持有彼此的引用，但一个外部对象只能持有对根对象的引用。如果边界内还有其他的实体，拿着洗实体的标识符是本地化的，只有聚合内有意义。
        </div>
        <div class="content-words">
            聚合保证一致性的原因是其他对象只能访问根对象而不可以访问根对象聚合内的其他对象。其他对象所能做的只有请求根的变更。
        </div>
        <div class="content-words">
            根对象可以将内部对象的临时引用传递给外部对象，作为限制，当操作完成后，外部对象不能持有这个引用。一种简单的实现方式是向外部对象传递值对象的副本。在副本对象上发生了什么事情将不再重要，因为它不会影响聚合的一致性。
        </div>
        <div class="content-words">
            聚合的对象存储于数据库时，可以通过查询来获得的应该只有根对象。其他的对象只能通过根对象出发导航关联的对象来获得。
        </div>
        <div class="content-words">
            聚合内的对象可以被允许持有对其他聚合的根对象的引用。
        </div>
        <div class="content-words">
            根实体拥有全局的标识符，并且有责任维护不变量。内部的实体拥有内部的标识符。
        </div>
        <div class="content-words">
            将尸体和值对象据聚集在聚合之中，并定义各个聚合之间的边界。为每个聚合选择一个实体作为根，并通过控制根来控制所有边界内的对象的访问。允许外部对象持有对根的引用。这种安排使强化聚合内的对象的不变量变得可行。对于聚合而言，它在任何状态变更中都是一个整体。
        </div>
        <div class="mermaid middle">
            classDiagram
            class ContactInfo {
            homePhoneNumber
            workPhoneNumber
            faxNumber
            emailAddress
            }
            class Address {
            street
            city
            state
            }
            Customer <|-- ContactInfo
            Customer <|-- Address
            Customer: customerId
            Customer: name
        </div>
        <div class="content-h4">
            Factory
        </div>
        <div class="content-words">
            实体和聚合常常很大很复杂。过于复杂以至于难以通过根实体的构造器来创建。实际上通过构造器构建一个复杂的聚合并不是领域本身通常应该做的事情。在领域中，某些事物时由别的事物创建的。创建一个对象可以是它自身的主要操作，但是复杂的组装应由工厂来获得。
        </div>
        <div class="content-words">
            工厂被用来封装对象创建所必须的知识，他们对创建聚合特别有用。当聚合的根被创建后，所有聚合所包括的对象都应该随之创建，所有的不变量得到强化。
        </div>
        <div class="content-words">
            保持创建过程的原子性非常重要。
        </div>
        <div class="content-words">
            为复杂对象和聚合的创建实例的职责，应该转交给一个单独的对象。虽然这个对象本身在领域模型中没有职责，但其仍是领域设计的一部分。将整个聚合当做一个单元来创建，强化它们的不变量。
        </div>
        <div class="content-words">
            有的时候创建对象的逻辑会非常复杂，或者创建对象涉及到创建其他一系列对象时，可以使用单独的工厂对象来隐藏聚合的内部构造所需要的任务。
        </div>
        <div class="content-words">
            当创建一个工厂时，我们被迫违反一个对象的封装原则，这必须谨慎行事。每当对象中发生了某种变化时，会对构造规则或者某些不变量造成影响。我们需要确保工厂也可以更新并支持新的条件。工厂与他们将要创建的对象是紧密关联的。较为合适的做法是使用一个专用的工厂类来负责创建整个聚合，在这个工厂类中将包含应该为聚合强化的规则、约束和不变量。这个对象会保持简单并完成特定目的。
        </div>
        <div class="content-words">
            有些时候，工厂不需要，构造器就足够。在如下情况应该使用构造器：
        </div>
        <div class="content-list">
            1. 构造过程不复杂
        </div>
        <div class="content-list">
            2. 对象的创建不涉及到其他对象的创建，可以将所有需要的属性传递给构造器
        </div>
        <div class="content-list">
            3. 客户对实现很感兴趣，可能希望使用策略（Strategy）模式
        </div>
        <div class="content-list">
            4. 类是特定的类型，不存在层级
        </div>
        <div class="content-words">
            另一个观察角度是工厂需要从无到有创建一个新对象，也可能是反序列化。反序列化包含的过程与创建不同，重建的新对象不需要标识符，这个对象已经有一个标识符了，对不变量的违反也将区别对待。当从无到有创建新对象时，任何对不变量的违反都会异常。对反序列化，我们不能这么处理，否则会数据丢失。
        </div>
        <div class="content-h4">
            Repository
        </div>
        <div class="content-words">
            创建对象完全是为了使用它们，我们必须持有对象的引用才能使用。为了获得这个引用，客户需要创建对象或是通过导航关联关系来获得它。在大型工程中，这会是一个问题：我们必须确保客户程序始终拥有所需要的对象的应用或导航。这会增加耦合性和一系列非真正需要的关联。
        </div>
        <div class="content-words">
            要使用一个对象，则说明它已经被创建完毕了。如果该对象是个根，则它是一个实体，会被保存为一个持久化的状态，可能是在数据库中。如果是个值对象，可以通过导航获取。实际上大量对象都可以从数据库中直接获取，这解决了获取对象引用的问题。当一个客户程序需要使用一个对象时，通过标识符访问数据库并检索使用。这看上去是简单的解决方案，但它会对设计产生负面影响。
        </div>
        <div class="content-words">
            数据库是基础设施的一部分，一个糟糕的解决方案是客户程序必须知道访问数据库所需的细节。例如，客户需要创建SQL查询语句来检索想要的数据。数据库查询可能会返回一组记录、甚至是更多内部的细节。当客户程序不得不直接从数据库创建对象时，会导致这样的代码扩散至整个模型而使领域模型遭受损害。它必须处理大量基础设施的细节而不是领域概念。如果对数据库的变更会导致所有扩散代码的变更。这样做会破坏封装、带来未知的结果。
        </div>
        <div class="content-words">
            因此，使用一个资源库，它的目的是封装所有获取对象引用所需的逻辑。领域对象不需处理基础设施，以得到领域中对其他对象的引用。只需要从资源库中获取它们，于是模型重获它应有的清晰和专注。
        </div>
        <div class="content-words">
            资源库会保存对某些对象的引用。当一个对象被创建后，它可以被保存在到资源库中，可以从资源库取出以备后续使用，
            <b>资源库扮演了全剧可访问对象的存储地点。</b>
            总体的结果时领域模型本身与需要保存对象或它们的引用、访问持久化基础设施实现了解藕。
        </div>
        <div class="content-words">
            对于需要全局访问的每种类型的对象，创建一个对象来提供该类型所有对象都在内存中的假象。通过一个众所周知的全局接口来设置访问途径。提供方法来添加或者删除对象，封装向数据存储中插入或者删除数据的实际操作。提供基于某些条件选择对象的方法，返回属性值符合条件的完全实例化的对象或对象集合，从而封装实际的存储和查询技术。仅仅为真正需要直接访问的聚合根提供资源库。让客户程序保持对模型的专注，将所有的对象存储和访问细节都委托给资源库。
        </div>
        <div class="content-words">
            资源库可以包含用来访问基础设施的细节信息，但它的接口应该非常简单。资源库应该拥有一组用来检索对象的方法。客户程序调用这样的方法，传递一个或者多个代表筛选条件的参数用来选择一个或者一组匹配的对象。可以通过传递实体的标识符来轻易指定一个实体。其他筛选条件可能由一组对象属性构成。资源库将所有的对象与这组条件来比较，并返回符合条件的那些对象。资源库接口可能还包含用来执行某些辅助计算
            (例如获取特定类型对象的数量)的方法。
        </div>
        <div class="content-words">
            <b>需要注意的是，资源库的实现可能会非常像是基础设施，然而资源库的接口却是纯粹的领域模型。</b>
        </div>
        <div class="content-h2">
            4. Refactoring for deeper understanding
        </div>
        <div class="content-h3">
            Continuous Refactor
        </div>
        <div class="content-words">
            模型必须与源自的领域紧密相连。代码设计应该围绕模型展开并改善。脱离了模型的设计会导致软件无法真实表达它所服务的领域，很可能会得不到期望的行为。
            建模如果得不到设计的反馈或者缺少了开发人员的参与，会导致必须实现模型的人很难理解它，并且对于所用的技术而言可能不太适合。
        </div>
        <div class="content-words">
            在设计和开发过程中，时不时停下来查看一下代码意味着到了重构的时间。重构通常是非常谨慎的，按照小幅且可控的步骤进行，这样我们就不会破坏功能或者引入一些 bug 了。
            毕竟，重构的目的是让代码更好而不是更坏。自动化测试可以为我们提供很大帮助，确保我们没有破坏任何事情<sup><a
                href="#6" id="source6">[6]</a></sup>。
        </div>
        <div class="content-words">
            还有另一种类型的重构，与领域和它的模型相关。有时会对领域有新的理解，有些事物变得更加清晰，或者发现了两个元素间的关系。所有的这些会通过重构工作被包括到设计中。得到容易阅读和理解的、有表现力的代码是非常重要的。通过阅读代码，一个人应该不仅仅能够了解代码是做什么的，同时了解它为什么要这样做。只有这样才能让代码真正捕获模型的实质。
        </div>
        <div class="content-words">
            与一致的语言一道使用经过验证的基础构造块，这样做会使得开发工作在某种程度 上保持明智。这带来了一个挑战：如何发现一个深刻的模型（Incisive
            model），这个模型能够捕获到领域专家头脑中微妙的概念，并且以此来驱动实际的设计。一个忽略肤浅 的表面内容且捕捉到基本内容的模型是一个深层模型（Deep
            model）。这会让软件更加与领域专家的思路合拍，也更能满足用户的需要。
        </div>
        <div class="content-words">
            从传统意义上讲，重构描述的是出于技术动机的代码转换。重构的动机同样可以出于对领域的深入理解，以及对模型及其代码表达进行相应的改进。
        </div>
        <div class="content-words">
            除非使用迭代的重构过程，加上领域专家和开发人员一起密切关注对领域的学习， 否则一个复杂成熟的领域模式是很难开发出来的。
        </div>
        <div class="content-h3">
            Highlight key concepts
        </div>
        <div class="content-words">
            我们会为模型添加新的概念和抽象，
            然后对基于模型的设计做重构。每一次改进都会让设计更加清晰，从而带来突破。突破常包括思维上的变化，如同我们理解模型一样。它也是项目中取得巨大进展的源泉，然而它也有一些缺点。突破可能隐含了大量的重构。这意味着需要时间和资源，大量的重构也会在应用中引入行为上的变化。
        </div>
        <div class="content-words">
            为达到一次突破，我们需要将隐含的概念显现出来。当我们跟领域专家交谈时，我们交换了大量的想法和知识。某些概念成为了通用语言的一部分，但也有一些概念在起初未被重视。在改进设计的过程中，我们发现这些概念在设计中担任了重要的角色。因此我们需要将这些隐含的概念显现出来。我们应该为它们创建类和关系。当这种情况出现时，我们就拥有了突破的机会。
        </div>
        <div class="content-words">
            隐含的概念可能不会仅于此。如果它们是领域概念，它们应该被引入到模型和设计中。我们应该如何识别它们呢?
        </div>
        <div class="content-words">
            第一种发现隐含概念的方式是倾听用到的语言。我们在建模和设计过程中使用的语言中包含了大量关于领域的信息。起初可能不会很多，或者某些信息没有被正确地使用。某些概念可能无法被完全理解，甚至理解是完全错误的。
            这是在学习一个新的领域所必须经历的一部分。但因为我们建造了我们的通用语言，关键概念会被加入其中。我们应该从那里开始查找隐含的概念。
        </div>
        <div class="content-words">
            有时设计的一些部分可能不会那么清晰，有一组关系让路径的计算变得难以进行，
            或者其过程会复杂到难以理解。这些部分在设计中显得十分笨拙，但这也是寻找隐藏的概念的绝佳之所。可能我们错过了什么。如果某个关键概念在破解谜团时缺失了，其他的事物就不得不替代它完成它的功能。这会让某些对象变胖。设计的清晰度受到了损害。努力寻找是否有缺失的概念，如果找到一个，就将它显现出来。对设计做重构，让它更简单、更具灵活性。
        </div>
        <div class="content-words">
            当我们构建知识时很可能会遇到矛盾的情况，一个需求可能看上去与另一个需求矛盾。有一些矛盾其实不是真正的矛盾，只是因为看待同一事物的方式不同，或者只是因为在讲解时缺乏精确度造成的。我们应该努力去解决矛盾，有时这确实会帮助我们发现重要的概念。即使并没有发现它们，能够保持所有事物清晰也是很重要的。
        </div>
        <div class="content-words">
            挖掘模型概念的另一种明显的方式是使用领域文献。现在有众多为几乎任何可能的主题而编写的书，它们包含了大量关于特定领域的知识。这些书通常不包含所介绍领域
            的模型，它们包含的信息需要进一步处理、提炼和改进。但是，在书中发现的信息是有价值的，会给我们提供对领域的深层视图。
        </div>
        <div class="content-words">
            在将概念显现出来时，还有其他一些非常有用的概念：约束、过程和规约。约束是一个很简单的表达不变量的方式。无论对象的数据如何变化，不变量都要得到保持。简单的实现方式是将不变量的逻辑放在一个约束中。
        </div>


        <div class="content-addition">
            <span id="1"><a href="#source1"> [1]</a> <a href="https://martinfowler.com/bliki/UbiquitousLanguage.html">https://martinfowler.com/bliki/UbiquitousLanguage.html</a></span><br/>
            <span id="2"><a href="#source2"> [2]</a> <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">https://en.wikipedia.org/wiki/Separation_of_concerns</a></span><br/>
            <span id="3"><a href="#source3"> [3]</a> <a href="https://en.wikipedia.org/wiki/Model-driven_architecture">https://en.wikipedia.org/wiki/Model-driven_architecture</a></span><br/>
            <span id="4"><a href="#source4"> [4]</a> <a
                    href="https://www.chegg.com/learn/computer-science/computer-software/communicational-cohesion">https://www.chegg.com/learn/computer-science/computer-software/communicational-cohesion</a></span><br/>
            <span id="5"><a href="#source5"> [5]</a> <a
                    href="https://www.oreilly.com/library/view/software-architects-handbook/9781788624060/f5a37a6f-dea3-4768-9f28-62e8e5f4d6ff.xhtml">https://www.oreilly.com/library/view/software-architects-handbook/9781788624060/f5a37a6f-dea3-4768-9f28-62e8e5f4d6ff.xhtml</a></span><br/>
            <span id="6"><a href="#source6"> [6]</a> <a href="../tdd/">详见TDD</a></span><br/>
        </div>
    </div>
</div>
</body>
</html>
<div class="back-to-home-page">
    <a class="call-to-action__link button" href="/">返回首页</a>
</div>
<script>
    var d = Diagram.parse("" +
        "开发人员->领域专家: 我们想监控空中交通，应该从哪里开始？\n" +
        "领域专家->开发人员: 让我们从最基础的开始吧。所有的交通由飞机组成。\n" +
        "领域专家->开发人员: 每架飞机从一个出发地起飞，并在一个目的地点着陆\n" +
        "开发人员->领域专家: 很容易嘛。在飞行时，飞机会按照驾驶员的意愿选择任何空中线路吗? \n" +
        "开发人员->领域专家: 是不是等于说他们可以决定他们能走哪条路，只要他们能到达终点?\n" +
        "领域专家->开发人员: 哦不。驾驶员会收到一条他们应该遵照的飞行路线。\n" +
        "领域专家->开发人员: 并且他们必须尽可能地 跟那条飞行路线吻合\n" +
        "开发人员->领域专家: 我会把这条路线考虑成空中的 3D 线路。\n" +
        "开发人员->领域专家: 如果我们使用笛卡尔系统坐标， \n" +
        "开发人员->领域专家: 那么一条飞行路线会被简化成一系列 3D 的点。\n" +
        "领域专家->开发人员: 我可不这么认为。我们不会这样看待飞行路线的。\n" +
        "领域专家->开发人员: 飞行路线实际上是飞机预期的空中线路在地面上的映射。\n" +
        "领域专家->开发人员: 飞行路线会穿过一系列地面上的点，\n" +
        "领域专家->开发人员: 而这些点我们可以用经度和纬度来决定。\n" +
        "开发人员->领域专家: 哦，那我们可以称每一个这样的点为一个方位，\n" +
        "开发人员->领域专家: 因为它是地球表面上的一个固定的点。\n" +
        "开发人员->领域专家: 我们将使用一系列2D的点来描述线路。\n" +
        "开发人员->领域专家: 顺便说一句，出发地和终点都属于方位。\n" +
        "开发人员->领域专家: 我们不再会将它们考虑成其他不同的概念\n" +
        "开发人员->领域专家: 飞行路线到达终点就如同它到达其他的方位一样。\n" +
        "开发人员->领域专家: 飞机必须遵照飞行路线，\n" +
        "开发人员->领域专家: 但这是否意味着它可以按照自己的意愿选择飞行高度呢?\n" +
        "领域专家->开发人员: 不。飞机在一个特定的时刻的海拔高度也会在飞行计划中有规定。\n" +
        "开发人员->领域专家: 飞行计划?那是什么意思?\n" +
        "领域专家->开发人员: 在离开机场之前，驾驶员会接到一个详细的飞行计划，\n" +
        "领域专家->开发人员: 包括所有关于这次飞行的信息：\n" +
        "领域专家->开发人员: 飞行路线、巡航高度、巡航速度和飞机的类型\n" +
        "领域专家->开发人员: 甚至机组成员的信息等\n" +
        "开发人员->领域专家: 噢，飞行计划看起来相当的重要。我们可得把它加到模型中。");
    d.drawSVG('diagram-1', {theme: 'simple'});
    d = Diagram.parse("" +
        "开发人员->领域专家: 好多了。当我看到这副图时，我会了解到很多事情。\n" +
        "开发人员->领域专家: 在监控空中交通时， 我们其实并不对飞机本身感兴趣，\n" +
        "开发人员->领域专家: 不管它是白色的还是蓝色的，也不管它是“波音”的还是“空客”的。\n" +
        "开发人员->领域专家: 我们对它们的“飞行”(flight)感兴趣。\n" +
        "开发人员->领域专家: 这才是我们实际上要跟踪和度量的东西。\n" +
        "开发人员->领域专家: 我认为我们应该对模型做些改变以确保其更加准确。");
    d.drawSVG('diagram-2', {theme: 'simple'});
    d = Diagram.parse("" +
        "Client -> Factory: creatUser(\"C0123\")\n" +
        "Factory -> Client: return Customer C0123\n" +
        "Client -> Repository: addCustomer(Customer C0123)\n" +
        "Repository -> Database: insertRow");
    d.drawSVG('diagram-3', {theme: 'simple'});
</script>
